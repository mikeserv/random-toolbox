#!/bin/bash
#
# Test ISO - just some small tests on an ISO to see what's written
# to an otherwise empty filesystem
#
# Optional command-line arguments:
#          -u as first argument to generate a UDF image
# and then, in any order:
#          image filename   (or defaults to testiso.iso).
#          source directory (or defaults to null)
#
# If given as arguments, the image file must not exist but the directory must.
#
# JL20150731

# Note UDF has a varaible serial number that causes hashes of subsequent
# runs to differ. Images without UDF are identical and produce the same hash.

# Give -u option to enable UDF (this option passed to mkisofs)
[[ "$1" == "-u" ]] && { declare -r UDF="-udf"; shift; }

# Accept arguments - an existing directory and a non-existing file
# given in any order.
# while (( $# ))
# looping over a single arg per iteration is better/portably done like
unset DIR IMG _Bad_Argument_
for arg do

#  automatic in for loop  
#  arg="$1"; shift

  [ -e "${arg:-${_Bad_Argument_?"''"}}/" ]
  case $?:${DIR##*/}/:${IMG##*/} in
  (1:*:?*|0:?*/*)
       "${_Bad_Argument?"$arg"}";;
  (1*) IMG=$arg;;
  (0*) DIR=$arg;;
  esac
done
readonly \
    "DIR=${DIR-/dev/null}"    \
    "IMG=${IMG-${0##*/}.iso}" \
    "SECTOR_SIZE=2048"        \
    "START_SECTOR=16"         \
    "MAX_ED=5"                \
    "HASH=sha256"

printf "%s '%s'%b" \
    "Making image" "$IMG" "" \
    "from directory" "$DIR" \\n

# byte to ascii hex - surely there has to be a better way?
# bytehex() { printf "%b" "${1:-\000}" | od -t x1 | { read offset hex; echo $hex; }; }
# maybe so?

bytehex(){ printf %x\\n "'$1"; }

# blank config

for s in APPI COPY ABST BIBL PREP PUBL SYSI VOLI VOLS
do    eval "printf $s=%s \"\$$s\""
done  > .mkisofsrc

# make an empty test iso with a fake timestamp
TZ=UTC faketime -f "1970-01-01 00:00:00" mkisofs -quiet -r -J "UDF" -o "$IMG" "$DIR"

# display header
isoinfo -d -i "$IMG"

# traverse volume descriptors
printf "Volume descriptors"

od -tx1 -vj "$((START_SECTOR*SECTOR_SIZE))" |
sed -ne's/.*[40]000  *\(..\).*/p'           | tr -s \\n ' '

# and extended descriptors
ed=0
while [ "$((ed+=1))" -lt "$MAX_ED" ]
do
  byte_offset=$(((sector+ed)*SECTOR_SIZE))
  id=$(dd if="$IMG" skip="$byte_offset" bs=1 count=4 2>/dev/null)
  printf %s " $id"
  if [ "MKI " = "$id" ]
  then
    echo "wiping next 100 bytes to erase creation time"
    dd if=/dev/zero of="$IMG" conv=notrunc seek="$((byte_offset+4))" bs=1 count=100 2>/dev/null
    break
  fi
done

# display image size, hash and name
# guess this is the only non-POSIX bit now
stat --printf="%s bytes; $HASH:" "$IMG"; ${HASH}sum "$IMG"
